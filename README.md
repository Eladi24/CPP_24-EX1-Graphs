## EX1 Graph and algorithms
מחבר: אלעד אימני

מייל: eladima66@gamil.com

## מבט כללי
במטלה זו מומשו מחלקה המייצגת גרף מכוון/לא מכוון וממושקל/לא ממושקל המיוצג באמצעות מטריצת שכנויות, ומגוון אלגוריתמים המבצעים פעולות שונות על הגרף. עבור מימוש האלגוריתמים האתר Geeksforgeeks הווה מקור להשראה.

## שימוש
שימוש בפרויקט בצורה נכונה יעשה בצעדים הבאים:
1. הורדה/FORK של הפרויקט מה-Git repository למחשב מקומי.
2. בניית קבצי ההרצה באמצעות הפקודה make ב-directory המתאים (ניתן לבנות קובץ הרצה בודד עבור demo או test).
3. הרצת קבצי ההרצה, בנוסף הקובץ demo מהווה קובץ ניסיו, כלומר ניתן להוסיף/להסיר אוביקטים כרצון המשתמש.

## מימוש אוביקט גרף
מימוש גרף נעשה באמצעות מטריצת שכנויות, מטריצה ריבועית כאשר בכל תא i,j מצביע על קיום/ היעדר של קשת מקדקוד i ל-j. הגרף יכול להיות ממושקל כאשר ערך קשת מסוימת שונה מ-1/0. ביצירת אובייקט מסוג גרף, ברירת המחדל שהגרף אינו מכוון אלא אם מטריצת השכנויות אינה סימטרית. 
השיטות שמחלקת גרף מחזיקה הן:
1. שיטה שמקבלת מערך דו מימדי המייצג מטריצת שכנויות וטוענת אותו לאוביקט גרף - loadGraph(). בשיטה זו מתבצעת קריאה לפונ' עזר לבדיקה האם הגרף מכוון, ומתבצעת בדיקת תקינות קלט שמוודא שאכן מטריצת השכנויות ריבועית.
2. שיטה המדפיסה את הגרף (מספר הקדקודים והקשתות) - printGraph().

3. 4 שיטות GET-ים המחזירות את מספר הקדקודים, צלעות, מטריצת השכנויות והמטריצה המשוכלפת.
4. 2 פונ' עזר. שיטה לבדיקת סימטריות מטריצת השכנויות ושיטה לספירת הקשתות בגרף. במידה והגרף אינו מכוון, נחלק את הספירה בחצי מכיוון שספרנו כל קשת פעמיים.

## מימוש אלגוריתמים
* קשירות בגרף (isConnected): במקרה שהגרף מכוון, השיטה מחזירה 1 אם הגרף קשיר חזק, אחרת 0. נפעיל את אלגוריתם DFS על מטריצת השכנויות. לאחר מכן נהפוך את הקשתות בגרף (נשכפל את מטקיצת השכנויות) ונפעיל את האלגוריתם על המטריצה המשוכלפת. במקרה הגרף לא מכוון, השיטה מחזירה 1 אם הגרף קשיר, אחרת 0. נפעיל את אלגוריתם DFS פעם אחת ונבדוק אם ביקרנו בכל הקדקודים.
* מסלול הקצר ביותר מנקודה אחת לאחרת (shortestPath): השיטה מחזירה מחרוזת עם המסלול הקצר ביותר, אם לא קיים כזה השיטה תחזיר 1-. אלגוריתם פלויד וורשל נבחר לפתור את הבעיה מכיוון שהאלגוריתם תומך בגרף מכוון/לא מכוון, בגרף ממושקל וגרף עם משקלים שלילים.
* מעגל בגרף (isContainsCycle): השיטה מדפיסה מעגל ומחזירה TRUE אם קיים מעגל. אחרת מחזירה FALSE ומדפיסה שלא קיים כזה. השיטה מפרידה למקרה שהגרף מכוון ומפעילה את אלגוריתם DFS המותאם לגרף מכוון, ובאופן דומה מפרידה למקרה שהגרף אינו מכוון. בנוסף, מתבצעת בדיקה שהגרף לא בעל משקלים שלילים, אחרת זורקת שגיאה מכיוון שDFS אינו תומך במשקלים שליליים.
* גרף דו צדדי (isBipartite): השיטה מחזירה מחרוזת עם החלוקה של הגרף ל-2 קבוצות קדקודים זרות במידה וקיימת, אחרת מחזירה "0". נפעיל את אלגוריתם צביעת גרף ב-2 צבעים שונים. אם נקבל קדקוד שצבוע באותו צבע של שכנו לא קיימת חלוקה כזו. אחרת, נחלק את הקדקודים ל-2 קבוצות כאשר צבע אחד מייצג את הקבוצה הראשונה והצבע השני מייצג את הקבוצה השניה.
* מעגל שלילי בגרף (negativeCycle): השיטה מחזירה מחרוזת עם המעגל השלילי בגרף אם קיים כזה, אחרת מחזירה "0". אלגוריתם פלויד מרשל נבחר מכיוון שבנוסף לכך האלגוריתם מחזיר מטריצה עם כל המסלולים מקדקוד לאחרים, האלגוריתם מוצא מעגל שלילי בגרף.

  ## חלוקת הקוד
  הפרויקט חולק ל5 קבצים עיקרים:
  * Graph.cpp/.hpp: הקובץ המכיל את מימוש מחלקת גרף המייצגת אובייקט גרף
  * Algoritms.cpp/.hpp: הקובץ המכיל את מימוש פתרונות לפעולות על גרף באמצעות אלגוריתמים מגוונים
  * demo.cpp: קובץ המכיל דוגמאות לאובייקטים מסוג גרף ושימוש במחלקה
  * Test.cpp: קובץ המכיל מקרי קצה שנועד לבדיקות תקינות הקוד ומימושים נכונים
  * TestCounter.cpp: קובץ המריץ את מקרי קצה שייצרנו בקובץ ה"ל
    
